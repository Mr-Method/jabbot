-*- mode: Outline; buffer-file-coding-system: utf-8-unix -*-

* Protocols

把 Message Protocol 改成 mail header

* 哲學，準繩

不要依靠句法樹

全部背下來

* 問句與資料

** 相輔相成：兩者會互相決定彼此的句型

Ex:
  資料：Cozy 咖啡好喝
  問句：Cozy 咖啡好喝嗎？

Ex:
  資料：某處風景好
  問句：何處風景好？

但資料不一定會先於問句出現，也可以由一問一答之間得知資料：

Ex:
  問：Cozy 咖啡好喝嗎？
  答：好喝
  得知資料：Cozy 咖啡好喝

Ex:
  問：兒童樂園好玩嗎？
  答：不好玩
  得知資料：兒童樂園不好玩

因此，在推敲資料之前須要能夠進行簡單的是非判定，如：
( A<->B 記號表示 A B 兩者同時存在，或同時不存在 )

  好笑 <-> 不好笑
  好看 <-> 不好看
  好聽 <-> 不好聽

等等，一般的情況可假設為：

  好<X> <-> 不好<X>

但是有也反例：

  好人 <-\-> 不好人
  好鳥 <-\-> 不好鳥

事實上

  好人 <-> 壞人
  好鳥 <-> 不鳥
   (不過鳥這個詞到底是什麼做用呢)

雖然前面伴隨「好」的詞表示正面意義，但負面意義的詞卻有許多語言上的慣例，
無法以「不好」全面通用。直觀來看，可能的實做法有：

  1. 記下所有資料
  2. 有人發問時，翻遍資料找到可能的答案
  3. 若有正面回應，則進一步進行語料再解析

事實上，對於任何是非題，答案的形式已經很固定：

  問句：兒童樂園好玩嗎？
  答句：兒童樂園好玩 | 兒童樂園不好玩

一正一反的答案只是將某個詞翻個面而已。因此可能的處理方式又多了一種：

  1. 看見問句時自種產生兩種答案
  2.A 以統計（投票）的方法，把大家的答案記下，然後在資料庫中存下
      高票的那一面。
  2.B 在資料庫之中找尋兩種答案之一。
  2.C 隨意回答，從使用者回饋來加減答案之正確性。

** 正反詞 （二分哲學）

各種詞常常前面會多伴隨一個「好」「不好」「壞」來修飾，（我稱為「前修飾
詞」）如前例：

  好笑 <-> 不好笑
  好看 <-> 不好看
  好聽 <-> 不好聽
  好人 <-> 壞人
  好鳥 <-> 不鳥

主要詞為「笑看聽人鳥」，但隨著前修飾詞的不同而產生了不同意義。本來不做
形容用的詞（笑看聽人）經過前修飾之後，整體卻成為了形容詞。這真是個大黑
洞。

還有很多修飾詞會造出正反詞，如：

  有鬼 <-> 沒有鬼
  有力 <-> 沒力 | 沒有力 | 無力

其他常見的通用規則如下：

  有<X> <-> 沒有<X>

二分哲學也可以程度化，以統計的方法從全世界的答案裡找出兩面的程度（總和
為 100%）。

** 程度詞

如果主要詞已經是個形容詞（奇怪、瘦），那麼修飾詞的作用就是在形容其程度。

  奇怪 <-> 好奇怪 | 不奇怪
  瘦   <-> 好瘦 | 不瘦
  會   <-> 不會 | 好會
  行   <-> 不行 | 好行

而這裡的修飾詞並不是成對出現，而且也不是任可主要詞都可以用同樣的修飾詞
來修飾。也沒有一定的規則來決定何者可以，何者不可用。

* Infobot facts

Infobot 的 fact 是個簡單不錯的好方法：

  A => A is blahblah good and blah-blah this, blahblah that.

當 User 有意無意提起 A 的時候, infobot 就會把 A 的事實說出來。

** Indirect fact pointer

如果再加上某種 fuzzy 機制，就可以從簡單的 keyword match 到
fact index-term :

  Funny, American, Lovely ==> A
  A => A is blahblah good and blah-blah this, blahblah that.

當 user 在一句之內同時提到關於 Funny,American,Lovely 的時候，
就會喚起 bot 對於 A 的記憶，這個時候 bot 可以送出提示：

  "Perhaps it is about A ?"

或是直接把 A 的事實說出來也行。
